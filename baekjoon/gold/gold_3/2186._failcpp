#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};

int N,M,K;
string target;
int targetSize = -1;
int result = 0;
vector<vector<char>> table;
struct point {
    int y,x, nums;
};
queue<point> Q;

void init() {
    string temp;
    cin >> N >> M >> K;

    table.resize(N, vector<char>(M, 0));
    for(int i = 0; i < N; i++) {
        cin >> temp;
        for(int j = 0; j < M; ++j) {
            table[i][j] = temp[j];
        }
    }
    cin >> target;
    targetSize = (int)target.size() - 1;
}

void BFS() {
    int nx, ny;
    while(!Q.empty()) {
        point curr = Q.front(); Q.pop();
        // cout << curr.y << " " << curr.x << " " << curr.nums << endl;

        for(int i = 0; i < 4; ++i) {
            for(int j = 1; j <= K; ++j) {
                ny = curr.y + dy[i]*j;
                nx = curr.x + dx[i]*j;

                if(nx >= M || nx < 0 || ny >= N || ny < 0) continue;

                if(table[ny][nx] == target[curr.nums+1]) {
                    if(curr.nums+1 == targetSize) result += 1;
                    else Q.push(point{ny,nx, curr.nums+1});
                }
            }
        }
    }
}


int main() {
    
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    init();
    for(int i = 0; i < N; ++i) {
        for(int j = 0; j < M; ++j) {
            if(table[i][j] == target[0]) Q.push(point{i,j,0});
        }
    }
    BFS();
    cout << result;


    return 0;
}